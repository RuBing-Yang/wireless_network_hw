diff -Nru ns-2.35.orig/aodv-uu/defs.h ns-2.35/aodv-uu/defs.h
--- ns-2.35.orig/aodv-uu/defs.h	2009-06-05 00:09:17.000000000 +0700
+++ ns-2.35/aodv-uu/defs.h	2015-05-16 09:28:39.032280000 +0700
@@ -60,7 +60,7 @@
 #define NS_INLINE inline
 #endif
 
-#define AODV_UU_VERSION "0.9"
+#define AODV_UU_VERSION "0.9.6"
 #define DRAFT_VERSION "rfc3561"
 
 #ifdef NS_PORT
@@ -73,7 +73,9 @@
 #define AODV_RT_LOG_PATH "/var/log/aodvd.rtlog"
 #endif				/* NS_PORT */
 
+#ifndef max
 #define max(A,B) ( (A) > (B) ? (A):(B))
+#endif
 
 #define MINTTL 1		/* min TTL in the packets sent locally */
 
diff -Nru ns-2.35.orig/aodv-uu/ns-2/aodv-uu.cc ns-2.35/aodv-uu/ns-2/aodv-uu.cc
--- ns-2.35.orig/aodv-uu/ns-2/aodv-uu.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.35/aodv-uu/ns-2/aodv-uu.cc	2011-04-13 23:25:44.000000000 +0700
@@ -0,0 +1,659 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2002 Uppsala University.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors: Björn Wiberg <bjorn.wiberg@home.se>
+ *          Erik Nordström <erik.nordstrom@it.uu.se>
+ *
+ *****************************************************************************/
+
+#include <string.h>
+#include <assert.h>
+
+#include "../common/encap.h"
+#include "aodv-uu.h"
+
+
+/* Method for determining the size of the AODVUU packet header type */
+int AODV_msg::size()
+{
+	return AODV_MSG_MAX_SIZE;
+}
+
+
+/* Tcl hooks for enabling the AODVUU packet header type */
+int hdr_aodvuu::offset_;
+
+static class AODVUUHeaderClass:public PacketHeaderClass {
+
+public:
+	AODVUUHeaderClass():PacketHeaderClass("PacketHeader/AODVUU",
+					      AODV_MSG_MAX_SIZE) {
+		bind_offset(&hdr_aodvuu::offset_);
+	}} class_rtProtoAODVUU_hdr;
+
+
+/* Tcl hooks for the AODVUU routing agent */
+static class AODVUUclass:public TclClass {
+
+public:
+	AODVUUclass():TclClass("Agent/AODVUU") {
+	} TclObject *create(int argc, const char *const *argv) {
+		/* argv[4] and up are arguments to the constructor */
+		assert(argc == 5);
+		return (new AODVUU((nsaddr_t) atoi(argv[4])));
+	}
+}
+
+	class_rtProtoAODVUU;
+
+
+/* Handler for investigating the queue of timers */
+void TimerQueueTimer::expire(Event *e)
+{
+	struct timeval *timeout;
+	timeout = agent_->timer_age_queue();
+
+	if (timeout)
+		resched((double) timeout->tv_sec +
+			(double) timeout->tv_usec / (double) 1000000);
+}
+
+
+/* Constructor for the AODVUU routing agent */
+NS_CLASS AODVUU(nsaddr_t id) : Agent(PT_AODVUU), ifindex(NS_IFINDEX), 
+			       initialized(0),
+			       tqtimer(this), ifqueue(0)
+{
+	/*
+	  Enable usage of some of the configuration variables from Tcl.
+
+	  Note: Do NOT change the values of these variables in the constructor
+	  after binding them! The desired default values should be set in
+	  ~ns/tcl/lib/ns-default.tcl instead.
+	*/
+	bind("unidir_hack_", &unidir_hack);
+	bind("rreq_gratuitous_", &rreq_gratuitous);
+	bind("expanding_ring_search_", &expanding_ring_search);
+	bind("local_repair_", &local_repair);
+	bind("receive_n_hellos_", &receive_n_hellos);
+	bind("hello_jittering_", &hello_jittering);
+	bind("wait_on_reboot_", &wait_on_reboot);
+	bind("debug_", &debug);
+	bind("rt_log_interval_", &rt_log_interval);	// Note: in milliseconds!
+	bind("log_to_file_", &log_to_file);
+	bind("optimized_hellos_", &optimized_hellos);
+	bind("ratelimit_", &ratelimit);
+	bind("llfeedback_", &llfeedback);
+	bind("internet_gw_mode_", &internet_gw_mode);
+  
+	/* Other initializations follow */
+
+	/* From main.c */
+	progname = strdup("AODV-UU");
+
+	/* From debug.c */
+	/* Note: log_nmsgs was never used anywhere */
+	log_nmsgs = 0;
+	log_file_fd = -1;
+	log_rt_fd = -1;
+
+	/* Set host parameters */
+	memset(&this_host, 0, sizeof(struct host_info));
+	memset(dev_indices, 0, sizeof(unsigned int) * MAX_NR_INTERFACES);
+	this_host.seqno = 1;
+	this_host.rreq_id = 0;
+
+	/* Set network interface parameters */
+	DEV_NR(NS_DEV_NR).enabled = 1;
+	DEV_NR(NS_DEV_NR).sock = -1;
+	DEV_NR(NS_DEV_NR).ifindex = NS_IFINDEX;
+	dev_indices[NS_DEV_NR] = NS_IFINDEX;
+
+	const char faked_ifname[] = "nsif";
+	strncpy(DEV_NR(NS_DEV_NR).ifname, faked_ifname, IFNAMSIZ - 1);
+	DEV_NR(NS_DEV_NR).ifname[IFNAMSIZ - 1] = '\0';
+
+	// Netmask not used in simulations
+	DEV_NR(NS_DEV_NR).netmask.s_addr = (in_addr_t) 0;
+
+	DEV_NR(NS_DEV_NR).broadcast.s_addr = AODV_BROADCAST;
+
+	// One enabled network interface (in total)
+	this_host.nif = 1;
+    
+	node_id = id;
+    
+	/* Set agent parameters */
+	addr() = id;
+	port() = RT_PORT;
+	dport() = RT_PORT;
+
+	INIT_LIST_HEAD(&rreq_records);
+	INIT_LIST_HEAD(&rreq_blacklist); 
+	INIT_LIST_HEAD(&seekhead);
+	INIT_LIST_HEAD(&TQ);
+
+	/* Initialize data structures */
+	worb_timer.data = NULL;
+	worb_timer.used = 0;
+	hello_timer.data = NULL;
+	hello_timer.used = 0;
+	rt_log_timer.data = NULL;
+	rt_log_timer.used = 0;
+	aodv_socket_init();
+	rt_table_init();
+	packet_queue_init();
+}
+
+
+/* Destructor for the AODV-UU routing agent */
+NS_CLASS ~ AODVUU()
+{
+	rt_table_destroy();
+	log_cleanup();
+}
+
+/*
+  Link layer callback function.
+  Used when link layer packet delivery fails.
+*/
+static void link_layer_callback(Packet *p, void *arg)
+{
+	((AODVUU *) arg)->packetFailed(p);
+}
+
+/* 
+   A small function used as filter to remove packets by destination
+   from the interface queue.
+*/
+int ifqueue_filter_on_dest(Packet *p, void *data)
+{
+	struct hdr_ip *ih = HDR_IP(p);
+	u_int32_t *addr = (u_int32_t *) data;
+	u_int32_t dest_addr = (u_int32_t) ih->daddr();
+    
+	return (dest_addr == *addr);
+}
+
+/*
+  Moves pending packets with a certain next hop from the interface
+  queue to the packet buffer or simply drops it.
+*/
+void NS_CLASS interfaceQueue(nsaddr_t addr, int action)
+{
+	Packet *q_pkt = NULL;
+	struct hdr_ip *ih = NULL;
+	struct in_addr dest_addr;
+    
+	/* Check that interface queue reference is valid */
+	if (ifqueue == NULL || ifqueue == 0) {
+		DEBUG(LOG_DEBUG, 0, "ifqueue is NULL!!!");
+		return;
+	}
+    
+	dest_addr.s_addr = addr;
+
+	/* Move packets from interface queue to packet buffer */
+	switch (action) {
+	case IFQ_DROP:
+		while ((q_pkt = ifqueue->filter(addr))) {
+			struct hdr_cmn *ch = HDR_CMN(q_pkt);
+
+			DEBUG(LOG_DEBUG, 0, "Dropping pkt for %s uid=%d", 
+			      ip_to_str(dest_addr), ch->uid());
+			drop(q_pkt, DROP_RTR_NO_ROUTE);    
+		}
+		break;
+	case IFQ_DROP_BY_DEST:
+		dest_addr.s_addr = addr;
+		DEBUG(LOG_DEBUG, 0, "Dropping pkts by dest for %s queue_len=%d", 
+		      ip_to_str(dest_addr), ifqueue->length());
+		ifqueue->filter(ifqueue_filter_on_dest, (void *) &addr);
+	    
+		break;
+	case IFQ_BUFFER:
+		while ((q_pkt = ifqueue->filter(addr))) {
+			ih = HDR_IP(q_pkt);
+			dest_addr.s_addr = ih->daddr();
+			packet_queue_add(q_pkt, dest_addr);
+			DEBUG(LOG_DEBUG, 0, "Rebuffered IFQ packet");
+		}
+		break;
+	default:
+		DEBUG(LOG_DEBUG, 0, "Unspecified action. Don't know what to do.");
+	}
+}
+
+
+/* Called for packets whose delivery fails at the link layer */
+void NS_CLASS packetFailed(Packet *p)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	rt_table_t *rt_next_hop, *rt;
+	struct in_addr dest_addr, src_addr, next_hop;
+	packet_t pt = ch->ptype();
+
+	dest_addr.s_addr = ih->daddr();
+	src_addr.s_addr = ih->saddr();
+	next_hop.s_addr = ch->next_hop();
+    
+	DEBUG(LOG_DEBUG, 0, "Got failure callback");
+	/* We don't care about link failures for broadcast or non-data packets */
+	if (!(DATA_PACKET(pt) || (pt == PT_PING) || (pt == PT_ENCAPSULATED)) ||
+	    dest_addr.s_addr == IP_BROADCAST || 
+	    dest_addr.s_addr == AODV_BROADCAST) {
+		drop(p, DROP_RTR_MAC_CALLBACK);
+		DEBUG(LOG_DEBUG, 0, "Ignoring callback");
+		goto end;
+	}
+	DEBUG(LOG_DEBUG, 0, "LINK FAILURE for next_hop=%s dest=%s uid=%d",
+	      ip_to_str(next_hop), ip_to_str(dest_addr), ch->uid());
+  
+	if (seek_list_find(dest_addr)) {
+		DEBUG(LOG_DEBUG, 0, "Ongoing route discovery, buffering packet...");
+		packet_queue_add(p, dest_addr);
+		goto end;
+	}
+    
+	rt_next_hop = rt_table_find(next_hop);
+	rt = rt_table_find(dest_addr);
+    
+	if (!rt_next_hop || rt_next_hop->state == INVALID)
+		goto drop;
+    
+	if (!rt || rt->state == INVALID)
+		goto drop;
+    
+	if (rt->next_hop.s_addr != next_hop.s_addr) {
+		DEBUG(LOG_DEBUG, 0, "next hop mismatch - DROPPING pkt");
+		drop(p, DROP_RTR_MAC_CALLBACK);
+		goto end;
+	}
+
+	/* Do local repair? */
+	if (local_repair && rt->hcnt <= MAX_REPAIR_TTL 
+	    /* && ch->num_forwards() > rt->hcnt */
+		) {
+	
+		/* Buffer the current packet */
+		packet_queue_add(p, dest_addr);
+
+		/* Buffer pending packets from interface queue */
+		interfaceQueue((nsaddr_t) next_hop.s_addr, IFQ_BUFFER);
+	
+		/* Mark the route to be repaired */
+		rt_next_hop->flags |= RT_REPAIR;
+		neighbor_link_break(rt_next_hop);
+		rreq_local_repair(rt, src_addr, NULL);
+
+	} else {
+
+		/* No local repair - just force timeout of link and drop packets */
+		neighbor_link_break(rt_next_hop);
+	drop:	
+		drop(p, DROP_RTR_MAC_CALLBACK);
+		interfaceQueue((nsaddr_t) next_hop.s_addr, IFQ_DROP);
+	}
+
+end:
+	/*
+	  The link layer event might have changed the timer queue,
+	  so we'd better reschedule the timer queue timer...
+	*/
+	scheduleNextEvent();
+}
+
+
+/* Entry-level packet reception */
+void NS_CLASS recv(Packet *p, Handler *)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	struct in_addr saddr;
+    
+	/* Routing agent must be started before processing packets */
+	assert(initialized);
+
+	saddr.s_addr = ih->saddr();
+
+	// Do network layer stuff
+	if (saddr.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr) {
+		// We are originating this packet.
+		if (ch->num_forwards() == 0) { 
+			// Set direction down and account
+			// for IP header
+			ch->direction() = hdr_cmn::DOWN;
+			ch->size() += IP_HDR_LEN;
+		} else {
+			/* Seems like a routing loop */
+			drop(p, DROP_RTR_ROUTE_LOOP);
+			goto end;
+		}
+	} else {
+		// We received this packet on the network interface
+		ch->direction() = hdr_cmn::UP;
+	}
+    
+	/* Handle packet depending on type */
+	switch(ch->ptype()) {
+	case PT_AODVUU:
+		recvAODVUUPacket(p);	// AODV-UU messages (control packets)
+		break;
+#ifdef CONFIG_GATEWAY
+	case PT_ENCAPSULATED:
+		// Decapsulate...
+		if (internet_gw_mode) {
+			rt_table_t *rev_rt, *next_hop_rt;
+			rev_rt = rt_table_find(saddr);
+
+			/* Update reverse route */
+			if (rev_rt && rev_rt->state == VALID) {
+				rt_table_update_timeout(rev_rt, ACTIVE_ROUTE_TIMEOUT);
+		 
+				next_hop_rt = rt_table_find(rev_rt->next_hop);
+		 
+				if (next_hop_rt && next_hop_rt->state == VALID &&
+				    rev_rt && next_hop_rt->dest_addr.s_addr != rev_rt->dest_addr.s_addr)
+					rt_table_update_timeout(next_hop_rt, ACTIVE_ROUTE_TIMEOUT);
+			}
+			/* Decapsulate the packet */
+			p = pkt_decapsulate(p);
+	     
+			/* Send to wired target (address classifier) */
+			target_->recv(p, (Handler *)0);
+			break;
+		}
+	
+#endif /* CONFIG_GATEWAY */
+	default:
+		processPacket(p);   // Data path
+	}
+   
+end:
+	/* Check if any other events are pending and reschedule the timeout */
+	scheduleNextEvent();
+}
+
+/* Sends a packet using the specified next hop and delay */
+void NS_CLASS sendPacket(Packet *p, struct in_addr next_hop, double delay)
+{
+	struct hdr_cmn *ch = HDR_CMN(p);
+	struct hdr_ip *ih = HDR_IP(p);
+	struct in_addr dest_addr, src_addr;
+	double jitter = 0.0;
+	
+	dest_addr.s_addr = ih->daddr();
+	src_addr.s_addr = ih->saddr();
+
+	// Act network layer, check for forwarding
+	if (ch->direction() == hdr_cmn::UP && 
+	    src_addr.s_addr != DEV_IFINDEX(ifindex).ipaddr.s_addr) {
+		// We are forwarding a packet
+		ih->ttl()--;
+	    
+		if (ih->ttl() < 1) {
+			DEBUG(LOG_WARNING, 0, "Dropping packet with TTL = 0.");
+			drop(p, DROP_RTR_TTL);
+			return;
+		}
+		// Change direction of forwarded packet
+		ch->direction() = hdr_cmn::DOWN;
+		
+	} else if (ch->direction() == hdr_cmn::DOWN && 
+		   src_addr.s_addr == DEV_IFINDEX(ifindex).ipaddr.s_addr) {
+		// Seems like we are originating this packet. Nothing
+		// to do really
+	} else {
+		// Undefined behavior. Should complain and drop packet
+		DEBUG(LOG_WARNING, 0, "Undefined packet behavior!");
+		drop(p);
+		return;
+	}
+   
+   	/* Set packet fields depending on packet type */
+	if (dest_addr.s_addr == AODV_BROADCAST) {
+		/* Broadcast packet */
+		ch->next_hop_ = 0;
+		ch->prev_hop_ = DEV_NR(NS_DEV_NR).ipaddr.s_addr;
+		ch->addr_type() = NS_AF_NONE;
+		jitter = 0.02 * Random::uniform();
+		
+		Scheduler::instance().schedule(ll, p, jitter);
+	} else {
+		/* Unicast packet */
+		ch->next_hop_ = next_hop.s_addr;
+		ch->prev_hop_ = DEV_NR(NS_DEV_NR).ipaddr.s_addr;
+		ch->addr_type() = NS_AF_INET;
+		
+		if (llfeedback) {
+			ch->xmit_failure_ = link_layer_callback;
+			ch->xmit_failure_data_ = (void *) this;
+		}
+		
+		Scheduler::instance().schedule(ll, p, delay);
+	}
+}
+
+
+/* Interpreter for commands from Tcl */
+int NS_CLASS command(int argc, const char *const *argv)
+{
+
+	TclObject *obj;
+    
+	if (strcasecmp(argv[1], "start") == 0) {
+		return startAODVUUAgent();
+	}
+    
+	/* tracetarget: target for trace info specific for the routing agent */
+	if (strcasecmp(argv[1], "tracetarget") == 0) {
+		// Note: Currently no such trace info is generated.
+		return TCL_OK;
+	}
+    
+	if (argc == 3) {
+	
+		if (strcasecmp (argv[1], "addr") == 0) {
+			DEV_NR(NS_DEV_NR).ipaddr.s_addr = Address::instance().str2addr(argv[2]);
+			return TCL_OK;
+		}
+		if((obj = TclObject::lookup(argv[2])) == 0) {
+			fprintf(stderr, "AODVUU: %s lookup of %s failed\n", argv[1], argv[2]);
+			return TCL_ERROR;
+		}
+		if (strcasecmp (argv[1], "node") == 0) {
+			node_ = (MobileNode*) obj;
+			return TCL_OK;
+		}
+		if (strcasecmp(argv[1], "if-queue") == 0) {
+			ifqueue = (PriQueue *)obj;
+			return TCL_OK;
+		}
+		if (strcasecmp(argv[1], "add-ll") == 0) {
+			ll = (NsObject*) obj;
+			return TCL_OK;
+		} 
+	}
+
+	/* Unknown commands are passed to the Agent base class */
+	return Agent::command(argc, argv);
+}
+
+
+/* Starts the AODV-UU routing agent */
+int NS_CLASS startAODVUUAgent()
+{
+	if (initialized == 0) {
+
+		log_init();
+
+		/* Set up the wait-on-reboot timer */
+		if (wait_on_reboot) {
+			timer_init(&worb_timer, &NS_CLASS wait_on_reboot_timeout, &wait_on_reboot);
+			timer_set_timeout(&worb_timer, DELETE_PERIOD);
+			DEBUG(LOG_NOTICE, 0, "In wait on reboot for %d milliseconds.",
+			      DELETE_PERIOD);
+		}
+		/* Schedule the first HELLO */
+		if (!llfeedback && !optimized_hellos)
+			hello_start();
+
+		/* Initialize routing table logging */
+		if (rt_log_interval)
+			log_rt_table_init();
+
+		/* Initialization complete */
+		initialized = 1;
+
+		DEBUG(LOG_DEBUG, 0, "Routing agent with IP = %s : %d started.",
+		      ip_to_str(DEV_NR(NS_DEV_NR).ipaddr), DEV_NR(NS_DEV_NR).ipaddr);
+
+		DEBUG(LOG_DEBUG, 0, "Settings:");
+		DEBUG(LOG_DEBUG, 0, "unidir_hack %s", unidir_hack ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "rreq_gratuitous %s", rreq_gratuitous ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "expanding_ring_search %s", expanding_ring_search ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "local_repair %s", local_repair ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "receive_n_hellos %s", receive_n_hellos ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "hello_jittering %s", hello_jittering ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "wait_on_reboot %s", wait_on_reboot ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "optimized_hellos %s", optimized_hellos ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "ratelimit %s", ratelimit ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "llfeedback %s", llfeedback ? "ON" : "OFF");
+		DEBUG(LOG_DEBUG, 0, "internet_gw_mode %s", internet_gw_mode ? "ON" : "OFF");
+		if (llfeedback) {
+			active_route_timeout = ACTIVE_ROUTE_TIMEOUT_LLF;
+			ttl_start = TTL_START_LLF;
+			delete_period =  DELETE_PERIOD_LLF;
+		} else {
+			active_route_timeout = ACTIVE_ROUTE_TIMEOUT_HELLO;
+			ttl_start = TTL_START_HELLO;
+			delete_period = DELETE_PERIOD_HELLO;
+		}
+
+		DEBUG(LOG_DEBUG, 0, "ACTIVE_ROUTE_TIMEOUT=%d", ACTIVE_ROUTE_TIMEOUT);
+		DEBUG(LOG_DEBUG, 0, "TTL_START=%d", TTL_START);
+		DEBUG(LOG_DEBUG, 0, "DELETE_PERIOD=%d", DELETE_PERIOD);
+	
+		/* Schedule the first timeout */
+		scheduleNextEvent();
+
+		return TCL_OK;
+
+	} else {
+
+		/* AODV-UU routing agent already started */
+		return TCL_ERROR;
+	}
+}
+Packet *NS_CLASS pkt_encapsulate(Packet *p, struct in_addr gw_addr) {
+	struct in_addr dest;
+	Packet *ep = allocpkt(); //sizeof(Packet*));
+
+	if (!ep) {
+		DEBUG(LOG_DEBUG, 0, "Enc ep==NULL!");
+		return NULL;
+	}
+	hdr_encap *eh = hdr_encap::access(ep);
+    
+	eh->encap(p);
+
+	hdr_cmn* ch_e = hdr_cmn::access(ep);
+	hdr_cmn* ch_p = hdr_cmn::access(p);
+    
+#define MIN_ENC_OVERHEAD 8
+
+	ch_e->ptype() = PT_ENCAPSULATED;
+	ch_e->size() = ch_p->size() + MIN_ENC_OVERHEAD;
+	ch_e->timestamp() = ch_p->timestamp();
+    
+	struct hdr_ip *ih_e = HDR_IP(ep);
+	struct hdr_ip *ih_p = HDR_IP(p);
+	dest.s_addr = ih_p->daddr();
+
+	ih_e->daddr() = gw_addr.s_addr; 
+	ih_e->saddr() = ih_p->saddr();
+
+	return ep;
+}
+
+Packet *NS_CLASS pkt_decapsulate(Packet *p) {
+	hdr_cmn* ch = hdr_cmn::access(p);
+	Packet *p_dec;
+    
+	if (ch->ptype() == PT_ENCAPSULATED) {
+		hdr_encap *eh = hdr_encap::access(p);
+		/* Now decapsulate the packet */
+		p_dec = eh->decap();
+	
+		/* Free the decapsulator packet */
+		Packet::free(p);
+		return p_dec;
+	}
+	return NULL;
+}
+
+/*
+  Reschedules the timer queue timer to go off at the time of the
+  earliest event (so that the timer queue will be investigated then).
+  Should be called whenever something might have changed the timer queue.
+*/
+void NS_CLASS scheduleNextEvent()
+{
+	struct timeval *timeout;
+	timeout = timer_age_queue();
+
+	if (timeout)
+		tqtimer.resched((double) timeout->tv_sec +
+				(double) timeout->tv_usec / (double) 1000000);
+}
+
+
+/*
+  Replacement for gettimeofday(), used for timers.
+  The timeval should only be interpreted as number of seconds and
+  fractions of seconds since the start of the simulation.
+*/
+int NS_CLASS gettimeofday(struct timeval *tv, struct timezone *tz)
+{
+	double current_time, tmp;
+
+	/* Timeval is required, timezone is ignored */
+	if (!tv)
+		return -1;
+
+	current_time = Scheduler::instance().clock();
+
+	tv->tv_sec = (long)current_time; /* Remove decimal part */
+	tmp = (current_time - tv->tv_sec) * 1000000;
+	tv->tv_usec = (long)tmp;
+
+	return 0;
+}
+
+
+/*
+  Replacement for if_indextoname(), used in routing table logging.
+*/
+char *NS_CLASS if_indextoname(int ifindex, char *ifname)
+{
+	assert(ifindex >= 0);
+	strncpy(ifname, DEV_IFINDEX(ifindex).ifname, IFNAMSIZ - 1);
+	DEV_IFINDEX(ifindex).ifname[IFNAMSIZ - 1] = '\0';
+	return ifname;
+}
diff -Nru ns-2.35.orig/aodv-uu/ns-2/aodv-uu.h ns-2.35/aodv-uu/ns-2/aodv-uu.h
--- ns-2.35.orig/aodv-uu/ns-2/aodv-uu.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.35/aodv-uu/ns-2/aodv-uu.h	2011-04-13 23:25:44.000000000 +0700
@@ -0,0 +1,254 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2002 Uppsala University.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors: Björn Wiberg <bjorn.wiberg@home.se>
+ *
+ *****************************************************************************/
+
+#ifndef _AODV_UU_H
+#define _AODV_UU_H
+
+/* Constants for interface queue packet buffering/dropping */
+#define IFQ_BUFFER 0
+#define IFQ_DROP 1
+#define IFQ_DROP_BY_DEST 2
+
+/* This is a C++ port of AODV-UU for ns-2 */
+#ifndef NS_PORT
+#error "To compile the ported version, NS_PORT must be defined!"
+#endif /* NS_PORT */
+
+
+/* System-dependent datatypes */
+/* Needed by some network-related datatypes */
+#include <sys/types.h>
+
+/* Network-related datatypes */
+/* Needed by <netinet/ip.h> on Sun Solaris */
+#include <netinet/in_systm.h>
+
+/* Header files from ns-2 */
+#include <common/packet.h>
+#include <common/timer-handler.h>
+#include <tools/random.h>
+#include <trace/cmu-trace.h>
+#include <queue/priqueue.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+/* Forward declaration needed to be able to reference the class */
+class AODVUU;
+
+/* Global definitions and lib functions */
+#include "../params.h"
+#include "../defs.h"
+#include "../list.h"
+
+/* Extract global data types, defines and global declarations */
+#undef NS_NO_GLOBALS
+#define NS_NO_DECLARATIONS
+
+#include "../timer_queue.h"
+#include "../aodv_hello.h"
+#include "../aodv_rerr.h"
+#include "../aodv_rrep.h"
+#include "../aodv_rreq.h"
+#include "../aodv_socket.h"
+#include "../aodv_timeout.h"
+#include "../debug.h"
+#include "../routing_table.h"
+#include "../seek_list.h"
+#include "../locality.h"
+
+#include "packet_queue.h"
+#include "packet_input.h"
+
+#undef NS_NO_DECLARATIONS
+
+/* In ns-2 we don't care about byte order */
+#undef ntohl
+#undef htonl
+#undef htons
+#undef ntohs
+
+#define ntohl(x) x
+#define htonl(x) x
+#define htons(x) x
+#define ntohs(x) x
+
+/* Timer class for managing the queue of timers */
+class TimerQueueTimer : public TimerHandler {
+public:
+	TimerQueueTimer(AODVUU *a) : TimerHandler() { agent_ = a; }
+	virtual void expire(Event *e);
+
+protected:
+	AODVUU *agent_;
+};
+
+
+/* The AODV-UU routing agent class */
+class AODVUU : public Agent {
+
+	friend class TimerQueueTimer;
+	
+	unsigned int ifindex; /* Always use ns interface */
+public:
+	AODVUU(nsaddr_t id);
+	~AODVUU();
+	void recv(Packet *p, Handler *);
+	int command(int argc, const char *const *argv);
+	void packetFailed(Packet *p);
+ 
+protected:
+	void interfaceQueue(nsaddr_t next_hop, int action);
+	void sendPacket(Packet *p, struct in_addr next_hop, double delay);
+	int startAODVUUAgent();
+	void scheduleNextEvent();
+	int gettimeofday(struct timeval *tv, struct timezone *tz);
+	char *if_indextoname(int ifindex, char *ifname);
+	Packet *pkt_encapsulate(Packet *p, struct in_addr gw_addr);
+	Packet *pkt_decapsulate(Packet *p);
+
+	int initialized;
+	TimerQueueTimer tqtimer;
+	PriQueue *ifqueue;
+	NsObject *ll; /* Pointer to link layer */
+	int  node_id;
+	MobileNode *node_;
+	NsObject *port_dmux_;
+	NsObject *wired_target_;
+
+/*
+  Extract method declarations (and occasionally, variables)
+  from header files
+*/
+#define NS_NO_GLOBALS
+#undef NS_NO_DECLARATIONS
+
+#undef _AODV_NEIGHBOR_H
+#include "../aodv_neighbor.h"
+
+#undef _AODV_HELLO_H
+#include "../aodv_hello.h"
+
+#undef _AODV_RERR_H
+#include "../aodv_rerr.h"
+
+#undef _AODV_RREP_H
+#include "../aodv_rrep.h"
+
+#undef _AODV_RREQ_H
+#include "../aodv_rreq.h"
+
+#undef _AODV_SOCKET_H
+#include "../aodv_socket.h"
+
+#undef _AODV_TIMEOUT_H
+#include "../aodv_timeout.h"
+
+#undef _DEBUG_H
+#include "../debug.h"
+
+#undef _ROUTING_TABLE_H
+#include "../routing_table.h"
+
+#undef _SEEK_LIST_H
+#include "../seek_list.h"
+
+#undef _TIMER_QUEUE_H
+#include "../timer_queue.h"
+
+#undef _LOCALITY_H
+#include "../locality.h"
+
+#undef _PACKET_INPUT_H
+#include "packet_input.h"
+
+#undef _PACKET_QUEUE_H
+#include "packet_queue.h"
+
+#undef NS_NO_GLOBALS
+
+	/* (Previously global) variables from main.c */
+	int log_to_file;
+	int rt_log_interval;
+	int unidir_hack;
+	int rreq_gratuitous;
+	int expanding_ring_search;
+	int internet_gw_mode;
+	int local_repair;
+	int receive_n_hellos;
+	int hello_jittering;
+	int optimized_hellos;
+	int ratelimit;
+	int llfeedback;
+	char *progname;
+	int wait_on_reboot;
+	struct timer worb_timer;
+  
+	/* Parameters that are dynamic configuration values: */
+	int active_route_timeout;
+	int ttl_start;
+	int delete_period;
+
+	/* From aodv_hello.c */
+	struct timer hello_timer;
+
+	/* From aodv_rreq.c */
+	list_t rreq_records;
+	list_t rreq_blacklist;
+  
+	/* From seek_list.c */
+	list_t seekhead;
+  
+	/* From aodv_socket.c */
+	char recv_buf[RECV_BUF_SIZE];
+	char send_buf[SEND_BUF_SIZE];
+
+	/* From debug.c */
+	int log_file_fd;
+	int log_rt_fd;
+	int log_nmsgs;
+	int debug;
+	struct timer rt_log_timer;
+
+	/* From defs.h */
+	struct host_info this_host;
+	unsigned int dev_indices[MAX_NR_INTERFACES];
+	inline int ifindex2devindex(unsigned int ifindex);
+  
+/* From timer_queue.c */
+	list_t TQ;
+};
+
+
+/* From defs.h (needs the AODVUU class declaration) */
+inline int NS_CLASS ifindex2devindex(unsigned int ifindex)
+{
+	int i;
+
+	for (i = 0; i < this_host.nif; i++)
+		if (dev_indices[i] == ifindex)
+			return i;
+
+	return -1;
+}
+
+#endif /* AODV_UU_H */
diff -Nru ns-2.35.orig/aodv-uu/ns-2/packet_input.cc ns-2.35/aodv-uu/ns-2/packet_input.cc
--- ns-2.35.orig/aodv-uu/ns-2/packet_input.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.35/aodv-uu/ns-2/packet_input.cc	2011-04-13 23:25:44.000000000 +0700
@@ -0,0 +1,218 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2001 Uppsala University & Ericsson AB.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors: Erik Nordström, <erik.nordstrom@it.uu.se>
+ *
+ *****************************************************************************/
+
+#include <common/ip.h>
+
+#include "aodv-uu.h"
+
+extern int internet_gw_mode, wait_on_reboot, optimized_hellos, llfeedback;
+extern struct timer worb_timer;
+/* Set this if you want lots of debug printouts: */
+/* #define DEBUG_PACKET */
+
+void NS_CLASS processPacket(Packet * p)
+{
+    rt_table_t *fwd_rt, *rev_rt;
+    struct in_addr dest_addr, src_addr, prev_hop;
+    u_int8_t rreq_flags = 0;
+    struct ip_data *ipd = NULL;
+    int pkt_flags = 0;
+    fwd_rt = NULL;		/* For broadcast we provide no next hop */
+    ipd = NULL;			/* No ICMP messaging */
+
+    struct hdr_cmn *ch = HDR_CMN(p);
+    struct hdr_ip *ih = HDR_IP(p);
+
+    src_addr.s_addr = ih->saddr();
+    dest_addr.s_addr = ih->daddr();
+    prev_hop.s_addr = ch->prev_hop_;
+
+    if (ch->direction() == hdr_cmn::NONE) {
+	    DEBUG(LOG_DEBUG, 0,
+		  "Packet with src=%s dst=%s has no direction. DROPPING!", 
+		  ip_to_str(src_addr), ip_to_str(dest_addr));
+	    drop(p);
+	    return;
+    } 
+#if DEBUG_PACKET
+    if (ch->direction() == hdr_cmn::DOWN) {
+	    DEBUG(LOG_DEBUG, 0,
+		  "Packet DOWN src=%s dst=%s prev_hop=%s", 
+		  ip_to_str(src_addr), ip_to_str(dest_addr), 
+		  ip_to_str(prev_hop));
+    } else if (ch->direction() == hdr_cmn::UP) {
+	    DEBUG(LOG_DEBUG, 0,
+		  "Packet UP src=%s dst=%s prev_hop=%s", 
+		  ip_to_str(src_addr), ip_to_str(dest_addr), 
+		  ip_to_str(prev_hop));
+    }
+#endif
+    /* If this is a TCP packet and we don't have a route, we should
+       set the gratuituos flag in the RREQ. */
+    if (ch->ptype() == PT_TCP) {
+	rreq_flags |= RREQ_GRATUITOUS;
+    }
+
+    /* If the packet is a broadcast packet we just let it go
+     * through... */
+    if (dest_addr.s_addr == IP_BROADCAST ||
+	dest_addr.s_addr == DEV_IFINDEX(ifindex).broadcast.s_addr) {
+	    
+	    DEBUG(LOG_DEBUG, 0,
+		  "Broadcast packet src=%s dst=%s prev_hop=%s", 
+		  ip_to_str(src_addr), ip_to_str(dest_addr), 
+		  ip_to_str(prev_hop));
+	    
+	    if (ch->direction() == hdr_cmn::DOWN)
+		    sendPacket(p, dest_addr, 0.0);
+	    else if (ch->direction() == hdr_cmn::UP)
+		    target_->recv(p, (Handler*)0);
+	return;
+    }
+    
+    /* Find the entry of the neighboring node and the destination  (if any). */
+    rev_rt = rt_table_find(src_addr);
+    fwd_rt = rt_table_find(dest_addr);
+
+#ifdef CONFIG_GATEWAY
+    /* Check if we have a route and it is an Internet destination (Should be
+     * encapsulated and routed through the gateway). */
+    if (fwd_rt && (fwd_rt->state == VALID) && 
+	(fwd_rt->flags & RT_INET_DEST)) {
+	/* The destination should be relayed through the IG */
+
+	rt_table_update_timeout(fwd_rt, ACTIVE_ROUTE_TIMEOUT);
+
+	p = pkt_encapsulate(p, fwd_rt->next_hop);
+
+	if (p == NULL) {
+	    DEBUG(LOG_ERR, 0, "IP Encapsulation failed!");
+	   return;	    
+	}
+	/* Update pointers to headers */
+	ch = HDR_CMN(p);
+	ih = HDR_IP(p);
+
+	dest_addr = fwd_rt->next_hop;
+	fwd_rt = rt_table_find(dest_addr);
+	pkt_flags |= PKT_ENC;
+    }
+#endif /* CONFIG_GATEWAY */
+
+    /* UPDATE TIMERS on active forward and reverse routes...  */
+
+    rt_table_update_route_timeouts(fwd_rt, rev_rt);
+
+    /* OK, the timeouts have been updated. Now see if either: 1. The
+       packet is for this node -> ACCEPT. 2. The packet is not for this
+       node -> Send RERR (someone want's this node to forward packets
+       although there is no route) or Send RREQ. */
+
+    /* If the packet is destined for this node, then just accept it. */
+    if (memcmp(&dest_addr, &DEV_IFINDEX(ifindex).ipaddr, 
+	       sizeof(struct in_addr)) == 0) {
+	
+	ch->size() -= IP_HDR_LEN;    // cut off IP header size 4/7/99 -dam
+	target_->recv(p, (Handler*)0);
+	p = NULL;
+	return;
+
+    }
+    if (!fwd_rt || fwd_rt->state == INVALID ||
+	(fwd_rt->hcnt == 1 && (fwd_rt->flags & RT_UNIDIR))) {
+
+	/* Check if the route is marked for repair or is INVALID. In
+	 * that case, do a route discovery. */
+	if (fwd_rt && (fwd_rt->flags & RT_REPAIR))
+	    goto route_discovery;
+
+	if (ch->direction() == hdr_cmn::UP) {
+
+	    struct in_addr rerr_dest;
+	    RERR *rerr;
+	    struct in_addr nh;
+	    nh.s_addr = ch->prev_hop_;
+	    
+	    DEBUG(LOG_DEBUG, 0,
+		  "No route, src=%s dest=%s prev_hop=%s - DROPPING!",
+		  ip_to_str(src_addr), ip_to_str(dest_addr),
+		  ip_to_str(nh));
+
+	    if (fwd_rt) {
+		rerr = rerr_create(0, fwd_rt->dest_addr,
+				   fwd_rt->dest_seqno);
+
+		rt_table_update_timeout(fwd_rt, DELETE_PERIOD);
+	    } else
+		rerr = rerr_create(0, dest_addr, 0);
+	    
+	    DEBUG(LOG_DEBUG, 0, "Sending RERR to prev hop %s for unknown dest %s", ip_to_str(src_addr), ip_to_str(dest_addr));
+	    
+	    /* Unicast the RERR to the source of the data transmission
+	     * if possible, otherwise we broadcast it. */
+	    
+	    if (rev_rt && rev_rt->state == VALID)
+		rerr_dest = rev_rt->next_hop;
+	    else
+		rerr_dest.s_addr = AODV_BROADCAST;
+
+	    aodv_socket_send((AODV_msg *) rerr, rerr_dest,
+			     RERR_CALC_SIZE(rerr), 1, &DEV_IFINDEX(ifindex));
+
+	    if (wait_on_reboot) {
+		DEBUG(LOG_DEBUG, 0, "Wait on reboot timer reset.");
+		timer_set_timeout(&worb_timer, DELETE_PERIOD);
+	    }
+
+	    /* DEBUG(LOG_DEBUG, 0, "Dropping pkt uid=%d", ch->uid()); */
+	    drop(p, DROP_RTR_NO_ROUTE);
+
+	    return;
+	}
+
+      route_discovery:
+	/* Buffer packets... Packets are queued by the ip_queue.o
+	   module already. We only need to save the handle id, and
+	   return the proper verdict when we know what to do... */
+
+	packet_queue_add(p, dest_addr);
+
+	if (fwd_rt && (fwd_rt->flags & RT_REPAIR))
+	    rreq_local_repair(fwd_rt, src_addr, ipd);
+	else
+	    rreq_route_discovery(dest_addr, rreq_flags, ipd);
+
+	return;
+
+    } else {
+	/* DEBUG(LOG_DEBUG, 0, "Sending pkt uid=%d", ch->uid()); */
+	sendPacket(p, fwd_rt->next_hop, 0.0);
+
+	/* When forwarding data, make sure we are sending HELLO messages */
+	gettimeofday(&this_host.fwd_time, NULL);
+
+	if (!llfeedback && optimized_hellos)
+	    hello_start();
+    }
+}
+
+/* EOF */
diff -Nru ns-2.35.orig/aodv-uu/ns-2/packet_input.h ns-2.35/aodv-uu/ns-2/packet_input.h
--- ns-2.35.orig/aodv-uu/ns-2/packet_input.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.35/aodv-uu/ns-2/packet_input.h	2011-04-13 23:25:44.000000000 +0700
@@ -0,0 +1,35 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2001 Uppsala University & Ericsson AB.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors: Erik Nordström, <erik.nordstrom@it.uu.se>
+ *
+ *****************************************************************************/
+#ifndef _PACKET_INPUT_H
+#define _PACKET_INPUT_H
+
+#ifndef NS_NO_DECLARATIONS
+/* Packet flags: */
+#define PKT_ENC 0x1       /* Packet is encapsulated */
+#define PKT_DEC 0x2 /* Packet arrived at GW and has been decapsulated (and
+		     * should therefore be routed to the Internet */ 
+
+void processPacket(Packet * p);
+
+#endif				/* NS_NO_DECLARATIONS */
+
+#endif				/* PACKET_INPUT_H */
diff -Nru ns-2.35.orig/aodv-uu/ns-2/packet_queue.cc ns-2.35/aodv-uu/ns-2/packet_queue.cc
--- ns-2.35.orig/aodv-uu/ns-2/packet_queue.cc	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.35/aodv-uu/ns-2/packet_queue.cc	2011-04-13 23:25:44.000000000 +0700
@@ -0,0 +1,228 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2001 Uppsala University & Ericsson AB.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors: Erik Nordström, <erik.nordstrom@it.uu.se>
+ *
+ *****************************************************************************/
+
+#include "aodv-uu.h"
+
+#define GARBAGE_COLLECT
+
+void NS_CLASS packet_queue_init(void)
+{
+    INIT_LIST_HEAD(&PQ.head);
+    PQ.len = 0;
+
+#ifdef GARBAGE_COLLECT
+    /* Set up garbage collector */
+    timer_init(&PQ.garbage_collect_timer, &NS_CLASS packet_queue_timeout, &PQ);
+
+    timer_set_timeout(&PQ.garbage_collect_timer, GARBAGE_COLLECT_TIME);
+#endif
+}
+
+
+void NS_CLASS packet_queue_destroy(void)
+{
+    int count = 0;
+    list_t *pos, *tmp;
+    
+    list_foreach_safe(pos, tmp, &PQ.head) {
+	struct q_pkt *qp = (struct q_pkt *)pos;
+	list_detach(pos);
+
+	drop(qp->p, DROP_END_OF_SIMULATION);
+
+	free(qp);
+	count++;
+	PQ.len--;
+    }
+
+    DEBUG(LOG_INFO, 0, "Destroyed %d buffered packets!", count);
+}
+
+/* Garbage collect packets which have been queued for too long... */
+int NS_CLASS packet_queue_garbage_collect(void)
+{
+    int count = 0;
+    list_t *pos, *tmp;
+    struct timeval now;
+    
+    gettimeofday(&now, NULL);
+    
+    list_foreach_safe(pos, tmp, &PQ.head) {
+	struct q_pkt *qp = (struct q_pkt *)pos;
+	if (timeval_diff(&now, &qp->q_time) > MAX_QUEUE_TIME) {
+	   
+	    list_detach(pos);
+
+	    drop(qp->p, DROP_RTR_QTIMEOUT); 
+	    
+	    free(qp);
+	    count++;
+	    PQ.len--;
+	}
+    }
+    
+    if (count) {
+        DEBUG(LOG_DEBUG, 0, "Removed %d packet(s)!", count);
+    }
+    
+    return count;
+}
+/* Buffer a packet in a FIFO queue. Implemented as a linked list,
+   where we add elements at the end and remove at the beginning.... */
+
+void NS_CLASS packet_queue_add(Packet * p, struct in_addr dest_addr)
+{
+    struct q_pkt *qp;
+    struct hdr_ip *ih;
+    struct hdr_cmn *ch = HDR_CMN(p);
+    
+    ih = HDR_IP(p);
+    
+    assert((unsigned int)ih->daddr() == dest_addr.s_addr);
+
+    if (PQ.len >= MAX_QUEUE_LENGTH) {
+	DEBUG(LOG_DEBUG, 0, "MAX Queue length! Removing first packet.");
+	if (!list_empty(&PQ.head)) {
+	    qp = (struct q_pkt *)PQ.head.next;
+	    
+	    list_detach(PQ.head.next);
+
+	    drop(qp->p, DROP_RTR_QFULL);
+	    free(qp);
+	    PQ.len--;
+	}
+    }
+
+    qp = (struct q_pkt *) malloc(sizeof(struct q_pkt));
+    
+    if (qp == NULL) {
+	fprintf(stderr, "Malloc failed!\n");
+	exit(-1);
+    }
+
+    qp->p = p;
+
+    qp->dest_addr = dest_addr;
+    
+    gettimeofday(&qp->q_time, NULL);
+    
+    list_add_tail(&PQ.head, &qp->l);
+
+    PQ.len++;
+
+    DEBUG(LOG_INFO, 0, "buffered pkt to %s uid=%d qlen=%u",
+	  ip_to_str(dest_addr), ch->uid(), PQ.len);
+}
+
+int NS_CLASS packet_queue_set_verdict(struct in_addr dest_addr, int verdict)
+{
+    int count = 0;
+    rt_table_t *rt, *next_hop_rt, *inet_rt = NULL;
+    list_t *pos, *tmp;
+
+    double delay = 0;
+#define ARP_DELAY 0.005
+    
+    if (verdict == PQ_ENC_SEND) {
+	inet_rt = rt_table_find(dest_addr);
+	
+	if (!inet_rt)
+	    return -1;
+	rt = rt_table_find(inet_rt->next_hop);
+    } else {
+	rt = rt_table_find(dest_addr);
+    }
+    
+    list_foreach_safe(pos, tmp, &PQ.head) {
+	 struct q_pkt *qp = (struct q_pkt *)pos;
+
+	if (qp->dest_addr.s_addr == dest_addr.s_addr) {
+	    
+	    list_detach(pos);
+	    
+	    switch (verdict) {
+	    case PQ_SEND:
+		
+		if (!rt)
+		    return -1;
+
+		/* Apparently, the link layer implementation can't handle
+		 * a burst of packets. So to keep ARP happy, buffered
+		 * packets are sent with ARP_DELAY seconds between
+		 * sends. */
+		sendPacket(qp->p, rt->next_hop, delay);
+		delay += ARP_DELAY;
+		break;
+	    case PQ_DROP:
+
+		drop(qp->p, DROP_RTR_NO_ROUTE);
+		break;
+#ifdef CONFIG_GATEWAY
+	    case PQ_ENC_SEND:
+		
+		if (!rt)
+		    return -1;
+
+		DEBUG(LOG_DEBUG, 0, "Encap. PQ_ENC_SEND");
+
+		qp->p = pkt_encapsulate(qp->p, inet_rt->next_hop);
+		
+		if (!qp->p) {
+		    DEBUG(LOG_ERR, 0, "Encapsulation failed...");
+		}	
+		
+		sendPacket(qp->p, rt->next_hop, delay);
+		delay += ARP_DELAY;
+		break;
+#endif /* CONFIG_GATEWAY */
+	    }
+	    free(qp);
+	    count++;
+	    PQ.len--;
+	}
+    }
+
+    /* Update rt timeouts */
+    if (rt && rt->state == VALID && 
+	(verdict == PQ_SEND || verdict == PQ_ENC_SEND)) {
+	if (dest_addr.s_addr != DEV_IFINDEX(rt->ifindex).ipaddr.s_addr) {
+	    if (verdict == PQ_ENC_SEND && inet_rt)
+		rt_table_update_timeout(inet_rt, ACTIVE_ROUTE_TIMEOUT);
+	    
+	    rt_table_update_timeout(rt, ACTIVE_ROUTE_TIMEOUT);
+	    
+	    next_hop_rt = rt_table_find(rt->next_hop);
+	    
+	    if (next_hop_rt && next_hop_rt->state == VALID && 
+		next_hop_rt->dest_addr.s_addr != rt->dest_addr.s_addr)
+		rt_table_update_timeout(next_hop_rt, ACTIVE_ROUTE_TIMEOUT);
+	}
+	
+	DEBUG(LOG_INFO, 0, "SENT %d packets to %s qlen=%u",
+	      count, ip_to_str(dest_addr), PQ.len);
+    } else if (verdict == PQ_DROP) {
+	DEBUG(LOG_INFO, 0, "DROPPED %d packets for %s!",
+	      count, ip_to_str(dest_addr));
+    }
+
+    return count;
+}
diff -Nru ns-2.35.orig/aodv-uu/ns-2/packet_queue.h ns-2.35/aodv-uu/ns-2/packet_queue.h
--- ns-2.35.orig/aodv-uu/ns-2/packet_queue.h	1970-01-01 08:00:00.000000000 +0800
+++ ns-2.35/aodv-uu/ns-2/packet_queue.h	2011-04-13 23:25:44.000000000 +0700
@@ -0,0 +1,65 @@
+/*****************************************************************************
+ *
+ * Copyright (C) 2001 Uppsala University & Ericsson AB.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Authors: Erik Nordström, <erik.nordstrom@it.uu.se>
+ *
+ *****************************************************************************/
+#ifndef _PACKET_QUEUE_H
+#define _PACKET_QUEUE_H
+
+#ifndef NS_NO_GLOBALS
+
+#define MAX_QUEUE_LENGTH 512
+#define MAX_QUEUE_TIME 10000 /* Maximum time packets can be queued (ms) */
+#define GARBAGE_COLLECT_TIME 1000 /* Interval between running the
+				   * garbage collector (ms) */
+
+/* Verdicts for queued packets: */
+enum {
+    PQ_DROP = 0,
+    PQ_SEND = 1,
+    PQ_ENC_SEND = 2
+};
+
+struct q_pkt {
+    list_t l;
+    struct in_addr  dest_addr;
+    struct timeval q_time;
+    Packet *p;
+};
+
+struct packet_queue {
+    list_t head;
+    unsigned int len;
+    struct timer garbage_collect_timer;
+};
+
+#endif				/* NS_NO_GLOBALS */
+
+#ifndef NS_NO_DECLARATIONS
+struct packet_queue PQ;
+
+void packet_queue_add(Packet * p, struct in_addr dest_addr);
+void packet_queue_init();
+void packet_queue_destroy();
+int packet_queue_set_verdict(struct in_addr dest_addr, int verdict);
+int packet_queue_garbage_collect(void);
+
+#endif				/* NS_NO_DECLARATIONS */
+
+#endif
diff -Nru ns-2.35.orig/common/packet.h ns-2.35/common/packet.h
--- ns-2.35.orig/common/packet.h	2010-05-10 05:28:41.000000000 +0700
+++ ns-2.35/common/packet.h	2015-05-16 08:36:11.913569000 +0700
@@ -200,7 +200,8 @@
 static const packet_t PT_MDART = 72;
 	
         // insert new packet types here
-static packet_t       PT_NTYPE = 73; // This MUST be the LAST one
+static const packet_t PT_AODVUU = 73;
+static packet_t       PT_NTYPE = 74; // This MUST be the LAST one
 
 enum packetClass
 {
@@ -417,6 +418,8 @@
 		name_[PT_DCCP_CLOSEREQ]="DCCP_CloseReq";
 		name_[PT_DCCP_RESET]="DCCP_Reset";
 
+		// AODVUU patch
+		name_[PT_AODVUU] = "AODVUU";
 		name_[PT_NTYPE]= "undefined";
 	}
 	static int addPacket(char *name);
diff -Nru ns-2.35.orig/linkstate/ls.h ns-2.35/linkstate/ls.h
--- ns-2.35.orig/linkstate/ls.h	2010-03-08 12:54:51.000000000 +0700
+++ ns-2.35/linkstate/ls.h	2015-04-04 08:45:48.822308000 +0700
@@ -134,7 +134,7 @@
 		return ib.second ? ib.first : baseMap::end();
 	}
 
-	void eraseAll() { erase(baseMap::begin(), baseMap::end()); }
+	void eraseAll() { this->erase(baseMap::begin(), baseMap::end()); }
 	T* findPtr(Key key) {
 		iterator it = baseMap::find(key);
 		return (it == baseMap::end()) ? (T *)NULL : &((*it).second);
diff -Nru ns-2.35.orig/Makefile.in ns-2.35/Makefile.in
--- ns-2.35.orig/Makefile.in	2011-10-23 23:29:54.000000000 +0700
+++ ns-2.35/Makefile.in	2015-05-16 08:36:11.913569000 +0700
@@ -53,13 +53,19 @@
 # for diffusion
 #DIFF_INCLUDES = "./diffusion3/main ./diffusion3/lib ./diffusion3/nr ./diffusion3/ns"
 
+# AODV-UU: Name of subdirectory with AODV-UU files,            
+# usually a symlink to the AODV-UU sources. If you change this,
+# ~ns/trace/cmu-trace.cc must be updated as well.              
+AODV_UU_DIR = aodv-uu
+AODV_UU_LIB = libaodv-uu.a
+
 CCOPT	= @V_CCOPT@ 
 STATIC	= @V_STATIC@
 #LDFLAGS	= $(STATIC)
 LDFLAGS	= @LDFLAGS@ 
 LDOUT	= -o $(BLANK)
 
-DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test
+DEFINE	= -DTCP_DELAY_BIND_ALL -DNO_TK @V_DEFINE@ @V_DEFINES@ @DEFS@ -DNS_DIFFUSION -DSMAC_NO_SYNC -DCPP_NAMESPACE=@CPP_NAMESPACE@ -DUSE_SINGLE_ADDRESS_SPACE -Drng_test -DAODV_UU -DNS_PORT 
 
 INCLUDES = \
 	-I. @V_INCLUDE_X11@ \
@@ -72,13 +78,15 @@
 	-I./diffusion3/lib/nr -I./diffusion3/ns \
 	-I./diffusion3/filter_core -I./asim/ -I./qs \
 	-I./diffserv -I./satellite \
-	-I./wpan
-
+	-I./wpan \
+	-I./$(AODV_UU_DIR)
 
 LIB	= \
 	@V_LIBS@ \
 	@V_LIB_X11@ \
 	@V_LIB@ \
+	-L$(AODV_UU_DIR) \
+	-laodv-uu \
 	-lm @LIBS@
 #	-L@libdir@ \
 
@@ -333,6 +341,7 @@
 	wpan/p802_15_4sscs.o wpan/p802_15_4timer.o \
 	wpan/p802_15_4trace.o wpan/p802_15_4transac.o \
 	apps/pbc.o \
+	$(AODV_UU_DIR)/$(AODV_UU_LIB) \
 	@V_STLOBJ@
 
 
@@ -396,6 +405,9 @@
 
 BUILD_NSE = @build_nse@
 
+# AODV-UU: Added phony targets for AODV-UU 
+.PHONY: aodv-uu-clean
+
 all: $(NS) $(BUILD_NSE) $(NSTK) all-recursive Makefile
 
 
@@ -433,7 +445,11 @@
 
 endif 
 
+$(AODV_UU_DIR)/$(AODV_UU_LIB):
+	cd $(AODV_UU_DIR) && $(MAKE) $(AODV_UU_LIB) NS_DEFS='$(DEFINE)' OPTS='$(CCOPT)' NS_INC='$(subst -I.,-I$(shell pwd),$(INCLUDES))'
 
+aodv-uu-clean:
+	cd $(AODV_UU_DIR) && $(MAKE) clean
 
 Makefile: Makefile.in
 	@echo "Makefile.in is newer than Makefile."
@@ -560,6 +576,9 @@
 install-recursive: force
 	for i in $(SUBDIRS); do ( cd $$i; $(MAKE) install; ) done
 
+clean: aodv-uu-clean
+	$(RM) $(CLEANFILES)
+
 clean: clean-recursive
 	$(RM) $(CLEANFILES)
 
diff -Nru ns-2.35.orig/queue/priqueue.cc ns-2.35/queue/priqueue.cc
--- ns-2.35.orig/queue/priqueue.cc	2010-05-10 05:28:41.000000000 +0700
+++ ns-2.35/queue/priqueue.cc	2015-05-16 08:36:11.961569000 +0700
@@ -95,6 +95,12 @@
 			recvHighPriority(p, h);
                         break;
 
+#ifdef AODV_UU                                 
+		case PT_AODVUU:                
+			recvHighPriority(p, h);
+			break;                 
+#endif /* AODV_UU */                           
+
                 default:
                         Queue::recv(p, h);
                 }
diff -Nru ns-2.35.orig/tcl/lib/ns-agent.tcl ns-2.35/tcl/lib/ns-agent.tcl
--- ns-2.35.orig/tcl/lib/ns-agent.tcl	2009-01-15 13:23:49.000000000 +0700
+++ ns-2.35/tcl/lib/ns-agent.tcl	2015-05-16 08:36:11.961569000 +0700
@@ -197,3 +197,12 @@
 Agent/AOMDV set dport_   0
 Agent/AOMDV set aomdv_prim_alt_path_len_diff_ 1
 Agent/AOMDV set aomdv_max_paths_ 3
+
+
+# AODV-UU routing agent
+Agent/AODVUU instproc init args {
+    $self next $args
+}
+
+Agent/AODVUU set sport_   0
+Agent/AODVUU set dport_   0
diff -Nru ns-2.35.orig/tcl/lib/ns-default.tcl ns-2.35/tcl/lib/ns-default.tcl
--- ns-2.35.orig/tcl/lib/ns-default.tcl	2010-07-04 05:45:45.000000000 +0700
+++ ns-2.35/tcl/lib/ns-default.tcl	2015-05-16 08:36:11.961569000 +0700
@@ -1590,3 +1590,20 @@
 
 Agent/MDART set macFailed_ true
 Agent/MDART set etxMetric_ true
+
+# AODV-UU routing agent
+Agent/AODVUU set unidir_hack_ 0
+Agent/AODVUU set rreq_gratuitous_ 0
+Agent/AODVUU set expanding_ring_search_ 1
+Agent/AODVUU set local_repair_ 0
+Agent/AODVUU set receive_n_hellos_ 0
+Agent/AODVUU set hello_jittering_ 0
+Agent/AODVUU set wait_on_reboot_ 0
+Agent/AODVUU set debug_ 0
+Agent/AODVUU set rt_log_interval_ 0
+Agent/AODVUU set log_to_file_ 0
+Agent/AODVUU set optimized_hellos_ 0
+Agent/AODVUU set ratelimit_ 1
+Agent/AODVUU set llfeedback_ 1
+Agent/AODVUU set internet_gw_mode_ 0
+
diff -Nru ns-2.35.orig/tcl/lib/ns-lib.tcl ns-2.35/tcl/lib/ns-lib.tcl
--- ns-2.35.orig/tcl/lib/ns-lib.tcl	2010-05-10 05:28:41.000000000 +0700
+++ ns-2.35/tcl/lib/ns-lib.tcl	2015-05-16 08:36:11.961569000 +0700
@@ -633,6 +633,10 @@
 		    AOMDV {
 			    set ragent [$self create-aomdv-agent $node]
 		    }
+		# AODV-UU routing agent
+		    AODVUU {
+			    $self at 0.0 "$node start-aodv"
+		    }
 		    MDART {
 			    set ragent [$self create-mdart-agent $node]
 		    }
@@ -696,7 +700,7 @@
 	    $ifqType_ $ifqlen_ $phyType_ $antType_ $topoInstance_ \
 			$inerrProc_ $outerrProc_ $FECProc_
 	# Attach agent
-	if {$routingAgent_ != "DSR"} {
+	if {$routingAgent_ != "DSR" && $routingAgent_ != "AODVUU" } {
 		$node attach $ragent [Node set rtagent_port_]
 	}
 	if {$routingAgent_ == "DIFFUSION/RATE" ||
@@ -716,7 +720,7 @@
 	# Bind routing agent and mip agent if existing basestation 
 	# address setting
         if { [info exist wiredRouting_] && $wiredRouting_ == "ON" } {
-		if { $routingAgent_ != "DSR" } {
+		if { $routingAgent_ != "DSR" && $routingAgent_ != "AODVUU" } {
 			$node mip-call $ragent
 		}
 	}
@@ -780,8 +784,12 @@
 	# DSR is a special case
 	if {$routingAgent_ == "DSR"} {
 		set nodeclass [$self set-dsr-nodetype]
-	} else {
-		set nodeclass Node/MobileNode
+	}  else {	                                  
+	  	if { $routingAgent_ == "AODVUU"} {        
+	  		set nodeclass Node/MobileNode/AODVNode
+	  	} else {                                  
+	  		set nodeclass Node/MobileNode         
+	  	}
 	}
 	return [eval new $nodeclass $args]
 }
diff -Nru ns-2.35.orig/tcl/lib/ns-mobilenode.tcl ns-2.35/tcl/lib/ns-mobilenode.tcl
--- ns-2.35.orig/tcl/lib/ns-mobilenode.tcl	2009-01-15 13:23:49.000000000 +0700
+++ ns-2.35/tcl/lib/ns-mobilenode.tcl	2015-05-16 08:36:11.961569000 +0700
@@ -928,3 +928,105 @@
 	eval $self next $args
 	$dsr_agent_ reset
 }
+
+##############################################################################
+# A MobileNode Class for AODV which is modeled after the SRNode Class
+# but with modifications.
+##############################################################################
+Class Node/MobileNode/AODVNode -superclass Node/MobileNode
+
+Node/MobileNode/AODVNode instproc init args {
+	$self instvar ragent_ dmux_ classifier_ entry_point_ address_
+
+        set ns [Simulator instance]
+
+	eval $self next $args	;# parent class constructor
+
+	if {$dmux_ == "" } {
+		# Use the default mash and shift
+		set dmux_ [new Classifier/Port]
+	}
+	set ragent_ [new Agent/AODVUU [$self id ]]
+
+	# setup address (supports hier-address) for AODV agent
+	$self addr $address_
+	$ragent_ addr $address_
+	$ragent_ node $self
+
+	# Add the node's own address to the port demuxer
+	$self add-route $address_ $dmux_
+
+	if { [Simulator set RouterTrace_] == "ON" } {
+		# Recv Target
+		set rcvT [$self mobility-trace Recv "RTR"]
+		set namfp [$ns get-nam-traceall]
+		if {  $namfp != "" } {
+			$rcvT namattach $namfp
+		}
+		$rcvT target $ragent_
+		set entry_point_ $rcvT	
+	} else {
+		# Recv Target
+		set entry_point_ $ragent_
+	}
+
+	$self set ragent_ $ragent_
+
+	# The target of the routing agent is the address classifier
+	$ragent_ target $classifier_
+
+	set nullAgent_ [$ns set nullAgent_]
+	
+	# The default target in the classifier is set to the
+	# nullAgent, since the routing agent already handled whatever
+	# needs to be handled
+	$classifier_ defaulttarget $nullAgent_
+	
+	# Packets to the routing agent and default port should be
+	# dropped, since we've already handled them in the routing
+	# agent at the entry.
+	$dmux_ install [Node set rtagent_port_] $nullAgent_
+	$dmux_ defaulttarget $nullAgent_
+
+	return $self
+}
+
+Node/MobileNode/AODVNode instproc start-aodv {} {
+	$self instvar ragent_
+	$ragent_ start
+}
+
+Node/MobileNode/AODVNode instproc entry {} {
+        $self instvar entry_point_
+        return $entry_point_
+}
+
+Node/MobileNode/AODVNode instproc add-interface args {
+	eval $self next $args
+
+	$self instvar ragent_ ll_ mac_ ifq_
+
+	set ns [Simulator instance]
+
+	if { [Simulator set RouterTrace_] == "ON" } {
+		# Send Target
+		set sndT [$self mobility-trace Send "RTR"]
+		set namfp [$ns get-nam-traceall]
+		if {$namfp != "" } {
+			$sndT namattach $namfp
+		}
+		$sndT target $ll_(0)
+		$ragent_ add-ll $sndT 
+	} else {
+		# Send Target
+		$ragent_ add-ll $ll_(0) 
+	}
+
+	$ragent_ if-queue $ifq_(0)
+}
+
+Node/MobileNode/AODVNode instproc reset args {
+	$self instvar ragent_
+	eval $self next $args
+	$ragent_ reset
+}
\ No newline at end of file
diff -Nru ns-2.35.orig/tcl/lib/ns-packet.tcl ns-2.35/tcl/lib/ns-packet.tcl
--- ns-2.35.orig/tcl/lib/ns-packet.tcl	2011-10-15 05:11:08.000000000 +0700
+++ ns-2.35/tcl/lib/ns-packet.tcl	2015-05-16 08:36:11.961569000 +0700
@@ -171,6 +171,7 @@
 	Mac 	# network wireless stack
 # Mobility, Ad-Hoc Networks, Sensor Nets:
 	AODV 	# routing protocol for ad-hoc networks
+	AODVUU  # as above, but Uppsala University version
 	Diffusion 	# diffusion/diffusion.cc
 	IMEP 	# Internet MANET Encapsulation Protocol, for ad-hoc networks
         MIP 	# Mobile IP, mobile/mip-reg.cc
diff -Nru ns-2.35.orig/trace/cmu-trace.cc ns-2.35/trace/cmu-trace.cc
--- ns-2.35.orig/trace/cmu-trace.cc	2011-10-03 05:32:35.000000000 +0700
+++ ns-2.35/trace/cmu-trace.cc	2015-05-16 08:36:11.913569000 +0700
@@ -51,6 +51,11 @@
 #include <tora/tora_packet.h> //TORA
 #include <imep/imep_spec.h>         // IMEP
 #include <aodv/aodv_packet.h> //AODV
+
+#ifdef AODV_UU
+#include <aodv-uu/ns-2/aodv-uu.h> // AODV-UU
+#endif /* AODV_UU */
+
 #include <aomdv/aomdv_packet.h>
 #include <mdart/mdart_packet.h>
 #include <mdart/mdart_function.h>
@@ -963,6 +968,174 @@
         }
 }
 
+
+#ifdef AODV_UU
+void CMUTrace::format_aodvuu(Packet *p, int offset) {
+
+        struct hdr_ip *ih = HDR_IP(p);
+        hdr_aodvuu *ah = HDR_AODVUU(p);
+        AODV_msg *aodv_msg = (AODV_msg *) ah;
+
+        RREQ *aodv_rreq = (RREQ *) aodv_msg;
+        RREP *aodv_rrep = (RREP *) aodv_msg;
+        RREP_ack *aodv_rrep_ack = (RREP_ack *) aodv_msg;
+        RERR *aodv_rerr = (RERR *) aodv_msg;
+
+        switch (aodv_msg->type) {
+
+        case AODV_RREQ:
+
+                if (pt_->tagged()) {
+                        // Tagged format currently not supported
+                } else if (newtrace_) {
+
+                        sprintf(pt_->buffer() + offset,
+                                "-P aodvuu -Pt 0x%x -Ph %d -Pb %d -Pd %d -Pds %d -Ps %d -Pss %d -Pc REQUEST ",
+                                aodv_rreq->type,
+                                aodv_rreq->hcnt,
+                                aodv_rreq->rreq_id,
+                                (nsaddr_t) aodv_rreq->dest_addr,
+                                aodv_rreq->dest_seqno,
+                                (nsaddr_t) aodv_rreq->orig_addr,
+                                aodv_rreq->orig_seqno);
+
+                } else {
+
+                        sprintf(pt_->buffer() + offset,
+                                "[0x%x %d %d [%d %d] [%d %d]] (REQUEST)",
+                                aodv_rreq->type,
+                                aodv_rreq->hcnt,
+                                ntohl(aodv_rreq->rreq_id),
+                                (nsaddr_t) aodv_rreq->dest_addr,
+                                aodv_rreq->dest_seqno,
+                                (nsaddr_t) aodv_rreq->orig_addr,
+                                aodv_rreq->orig_seqno);
+                }
+
+                break;
+
+        case AODV_HELLO:
+
+                /* FALLS THROUGH (HELLO:s are sent as RREP:s) */
+
+        case AODV_RREP:
+
+                if (pt_->tagged()) {
+                        // Tagged format currently not supported
+                } else if (newtrace_) {
+
+                        sprintf(pt_->buffer() + offset,
+                                "-P aodvuu -Pt 0x%x -Ph %d -Pd %d -Pds %d -Ps %d -Pl %f -Pc %s ",
+                                aodv_rrep->type,
+                                aodv_rrep->hcnt,
+                                (nsaddr_t) aodv_rrep->dest_addr,
+                                aodv_rrep->dest_seqno,
+				(nsaddr_t) aodv_rrep->orig_addr,
+                                (double) aodv_rrep->lifetime,
+                                (ih->daddr() == (nsaddr_t) AODV_BROADCAST &&
+                                 ih->ttl() == 1) ? "HELLO" : "REPLY");
+                } else {
+
+                        sprintf(pt_->buffer() + offset,
+                                "[0x%x %d [%d %d] [%d] %f] (%s)",
+                                aodv_rrep->type,
+                                aodv_rrep->hcnt,
+                                (nsaddr_t) aodv_rrep->dest_addr,
+                                aodv_rrep->dest_seqno,
+				(nsaddr_t) aodv_rrep->orig_addr,
+                                (double) aodv_rrep->lifetime,
+                                (ih->daddr() == (nsaddr_t) AODV_BROADCAST &&
+                                 ih->ttl() == 1) ? "HELLO" : "REPLY");
+                }
+
+                break;
+
+        case AODV_RERR:
+
+                /*
+                  Note 1:
+
+                  The "hop count" (-Ph and its corresponding field in
+                  the old trace format) is actually the DestCount.
+
+                  This is a reminiscence from the AODV trace format,
+                  where RREP:s, RERR:s and HELLO:s are treated equally
+                  in terms of logging.
+
+                  Note 2:
+
+                  Lifetime field does not exist for RERR:s.
+                  Again a reminiscence from the AODV trace format
+                  (where that field isn't even initialized!).
+                  Therefore lifetime is set to 0.0 all the time for RERR:s.
+		*/
+
+                if (pt_->tagged()) {
+                        // Tagged format currently not supported
+                } else if (newtrace_) {
+
+                        sprintf(pt_->buffer() + offset,
+                                "-P aodvuu -Pt 0x%x -Ph %d -Pd %d -Pds %d -Pl %f -Pc ERROR ",
+                                aodv_rerr->type,
+                                aodv_rerr->dest_count,
+                                (nsaddr_t) aodv_rerr->dest_addr,
+                                aodv_rerr->dest_seqno,
+                                0.0);
+                } else {
+
+                        sprintf(pt_->buffer() + offset,
+                                "[0x%x %d [%d %d] %f] (ERROR)",
+                                aodv_rerr->type,
+                                aodv_rerr->dest_count,
+                                (nsaddr_t) aodv_rerr->dest_addr,
+                                aodv_rerr->dest_seqno,
+                                0.0);
+                }
+
+                break;
+
+        case AODV_RREP_ACK:
+
+                /*
+                  Note 3:
+
+                  RREP-ACK logging didn't exist in the AODV trace format.
+		*/
+
+                if (pt_->tagged()) {
+                        // Tagged format currently not supported
+                } else if (newtrace_) {
+
+                        sprintf(pt_->buffer() + offset,
+                                "-P aodvuu -Pt 0x%x RREP-ACK ",
+                                aodv_rrep_ack->type);
+                } else {
+
+                        sprintf(pt_->buffer() + offset,
+                                "[%d] (RREP-ACK)",
+                                aodv_rrep_ack->type);
+                }
+
+                break;
+
+        default:
+
+#ifdef WIN32
+                fprintf(stderr,
+                        "CMUTrace::format_aodvuu: invalid AODVUU packet type\n");
+#else
+                fprintf(stderr,
+                        "%s: invalid AODVUU packet type\n", __FUNCTION__);
+#endif
+                abort();
+
+                break;
+        }
+}
+#endif /* AODV_UU */
+
+
+
 // AOMDV patch
 void
 CMUTrace::format_aomdv(Packet *p, int offset)
@@ -1456,7 +1629,14 @@
 		case PT_GAF:
 		case PT_PING:
 			break;
-		default:
+#ifdef AODV_UU                                    
+		case PT_ENCAPSULATED:                      
+			break;                                 
+		case PT_AODVUU:                   
+			format_aodvuu(p, offset); 
+			break;                    
+#endif /* AODV_UU */                              		
+	default:
 
 			if(pktTrc_ && pktTrc_->format_unknow(p, offset, pt_, newtrace_))
 				break;
diff -Nru ns-2.35.orig/trace/cmu-trace.h ns-2.35/trace/cmu-trace.h
--- ns-2.35.orig/trace/cmu-trace.h	2010-05-10 05:28:41.000000000 +0700
+++ ns-2.35/trace/cmu-trace.h	2015-05-16 08:36:11.913569000 +0700
@@ -162,6 +162,9 @@
 	void    format_aomdv(Packet *p, int offset);
 	void    format_mdart(Packet *p, int offset);
 
+#ifdef AODV_UU
+        void    format_aodvuu(Packet *p, int offset);
+#endif /* AODV_UU */
 	// This holds all the tracers added at run-time
 	static PacketTracer *pktTrc_;
 
